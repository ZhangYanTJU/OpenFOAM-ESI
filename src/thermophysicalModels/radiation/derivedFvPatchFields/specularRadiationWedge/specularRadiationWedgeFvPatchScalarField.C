/*---------------------------------------------------------------------------*\
  =========                 |
  \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
   \\    /   O peration     |
    \\  /    A nd           | www.openfoam.com
     \\/     M anipulation  |
-------------------------------------------------------------------------------
    Copyright (C) 2023 Wikki Ltd.
    Copyright (C) 2023 OpenCFD Ltd.
-------------------------------------------------------------------------------
License
    This file is part of OpenFOAM.

    OpenFOAM is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.

\*---------------------------------------------------------------------------*/

#include "radiationModel.H"
#include "fvDOM.H"
#include "specularRadiationWedgeFvPatchScalarField.H"
#include "addToRunTimeSelectionTable.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{
namespace radiation
{
// * * * * * * * * * * * * * Private Member Functions  * * * * * * * * * * * //

void specularRadiationWedgeFvPatchScalarField::calcReceivedRayIDs() const
{
    if (receivedRayIDPtr_)
    {
        FatalErrorIn
        (
            "specularRadiationWedgeFvPatchScalarField"
            "::calcreceivedRayIDs()"
        )   << "receivedRayIDPtr already calculated"
            << abort(FatalError);
    }

    receivedRayIDPtr_ = new labelListList(this->size());
    labelListList& receivedRayID = *receivedRayIDPtr_;

    // Get access to radiation model, and recast as fvDOM
    const radiationModel& radiation =
        this->db().lookupObject<radiationModel>("radiationProperties");

    const fvDOM& dom(refCast<const fvDOM>(radiation));

    // Get rayId and lambda Id for this ray
    label rayId = -1;
    label lambdaId = -1;
    // dom.setRayIdLambdaId(dimensionedInternalField().name(), rayId, lambdaId);
    dom.setRayIdLambdaId(internalField().name(), rayId, lambdaId);

    // Get index of active ray
    // word rayAndBand = this->dimensionedInternalField().name();
    word rayAndBand = this->internalField().name();
    rayAndBand =
        rayAndBand.substr(rayAndBand.find("_")+1, rayAndBand.size()-1);


    const tensor& cellT = refCast<const wedgeFvPatch>(this->patch()).cellT();


    // Get all ray directions
    List<vector> dAve(dom.nRay());
    forAll (dAve, rayI)
    {
        dAve[rayI] = dom.IRay(rayI).dAve()/mag(dom.IRay(rayI).dAve());

        transform(cellT, dAve);
    }

    // Get face normal vectors
    //vectorField nHat = this->patch().nf();
    vectorField nHat(this->patch().nf());


    // For each face, and for each reflected ray, try to find another
    // ray that is better suited to pick it up.
    forAll(receivedRayID, faceI)
    {
        // Access the list of received rays for this face
        labelList& receivedRayIDs = receivedRayID[faceI];

        // Check whether ray is going into surface
        // -> no reflection
        if ((dAve[rayId] & nHat[faceI]) > 0)
        {
            receivedRayIDs.setSize(0);
            continue;
        }


        // For each face, initialize list of picked up
        // rays to maximum possible size
        receivedRayIDs.setSize(dom.nRay() - 1);

        // Count actual number of receiving rays
        label nReceiving = 0;

        forAll(dAve, incomingRayI)
        {
            // Calculate reflected ray direction for rayI
            vector dReflected =
                dAve[incomingRayI]
              - 2*(dAve[incomingRayI] & nHat[faceI])*nHat[faceI];

            // Get dot product with this ray
            scalar dotProductThisRay = dAve[rayId] & dReflected;

            // Assume this ray is closest to the reflected ray
            bool closest = true;

            // And look through all other rays to find a better suited one
            forAll(dAve, receivingRayI)
            {
                if (receivingRayI == rayId)
                {
                    // Do not compare this ray with itself
                    continue;
                }

                scalar dotProductOtherRay = dAve[receivingRayI] & dReflected;
                if (dotProductThisRay < dotProductOtherRay)
                {
                    // If another ray is closer, stop search
                    closest = false;
                    break;
                }
            }

            if (closest)
            {
                // Could not find better suited ray, so this ray needs to
                // pick it up. Add incoming ray to list for this face
                receivedRayIDs[nReceiving] = incomingRayI;
                nReceiving ++;
            }

        }

        // Resize list of picked up rays for this face
        receivedRayIDs.setSize(nReceiving);
    }

    // Sanity check on last ray
    if (rayId == (dom.nRay() - 1))
    {
        forAll(nHat, faceI)
        {
            label incomingRays = 0;
            label pickedUpRays = 0;

            for (label rayI = 0; rayI < dom.nRay(); rayI++)
            {
                // Is this ray going into the wall?
                if ((dAve[rayI] &  nHat[faceI]) > 0)
                {
                    incomingRays++;
                }

                // How many rays are picked up by this ray?
                const specularRadiationWedgeFvPatchScalarField& rayBC =
                    refCast
                    <
                        const specularRadiationWedgeFvPatchScalarField
                    >
                    (
                        dom.IRayLambda
                        (
                            rayI,
                            lambdaId
                        ).boundaryField()[patch().index()]
                    );

                const labelListList& receivedRaysList = rayBC.receivedRayIDs();

                pickedUpRays += receivedRaysList[faceI].size();
            }

            if (incomingRays != pickedUpRays)
            {
                FatalErrorIn
                (
                    "specularRadiationWedgeFvPatchScalarField"
                    "::calcreceivedRayIDs()"
                )   << "Sanity checked failed on patch " << patch().name()
                    << " face " << faceI << nl
                    << "number of rays with direction into wall: "
                    << incomingRays
                    << ", number of reflected rays picked up by outgoing rays: "
                    << pickedUpRays << nl
                    << abort(FatalError);
            }
        }
    }

}


// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //

specularRadiationWedgeFvPatchScalarField::
specularRadiationWedgeFvPatchScalarField
(
    const fvPatch& p,
    const DimensionedField<scalar, volMesh>& iF
)
:
    // mixedFvPatchField<scalar>(p, iF),
    wedgeFvPatchField<scalar>(p, iF),
    receivedRayIDPtr_(nullptr)
{
    /*
    this->refValue() = 0;
    this->refGrad() = 0;
    this->valueFraction() = 0;
    */
}


specularRadiationWedgeFvPatchScalarField::
specularRadiationWedgeFvPatchScalarField
(
    const specularRadiationWedgeFvPatchScalarField& ptf,
    const fvPatch& p,
    const DimensionedField<scalar, volMesh>& iF,
    const fvPatchFieldMapper& mapper
)
:
    //mixedFvPatchField<scalar>(ptf, p, iF, mapper),
    wedgeFvPatchField<scalar>(ptf, p, iF, mapper),
    receivedRayIDPtr_(nullptr)
{}


specularRadiationWedgeFvPatchScalarField::
specularRadiationWedgeFvPatchScalarField
(
    const fvPatch& p,
    const DimensionedField<scalar, volMesh>& iF,
    const dictionary& dict
)
:
    //mixedFvPatchField<scalar>(p, iF),
    wedgeFvPatchField<scalar>(p, iF),
    receivedRayIDPtr_(nullptr)
{
    /*
    this->refValue() = 0;
    this->refGrad() = 0;
    this->valueFraction() = 0;
    */

    /*
    if (dict.found("patchType"))
    {
        word& pType = const_cast<word &>(this->patchType());
        pType = word(dict.lookup("patchType"));
    }

    if (dict.found("value"))
    {
        fvPatchField<scalar>::operator=
        (
            scalarField("value", dict, p.size())
        );
    }
    else
    {
        fvPatchScalarField::operator=(this->refValue());
    }
    */
}


specularRadiationWedgeFvPatchScalarField::
specularRadiationWedgeFvPatchScalarField
(
    const specularRadiationWedgeFvPatchScalarField& ptf,
    const DimensionedField<scalar, volMesh>& iF
)
:
    //mixedFvPatchField<scalar>(ptf, iF),
    wedgeFvPatchField<scalar>(ptf, iF),
    receivedRayIDPtr_(nullptr)
{}


specularRadiationWedgeFvPatchScalarField::
specularRadiationWedgeFvPatchScalarField
(
    const specularRadiationWedgeFvPatchScalarField& ptf
)
:
    //mixedFvPatchField<scalar>(ptf),
    wedgeFvPatchField<scalar>(ptf),
    receivedRayIDPtr_(nullptr)
{}


// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //

const Foam::labelListList&
specularRadiationWedgeFvPatchScalarField::receivedRayIDs() const
{
    if (!receivedRayIDPtr_)
    {
        calcReceivedRayIDs();
    }

    return *receivedRayIDPtr_;
}


// Evaluate the field on the patch
void specularRadiationWedgeFvPatchScalarField::updateCoeffs()
{
    if (this->updated())
    {
        return;
    }

    //vectorField nHat = this->patch().nf();
    vectorField nHat(this->patch().nf());

    // Get access to radiation model, and recast as fvDOM
    const radiationModel& radiation =
        this->db().lookupObject<radiationModel>("radiationProperties");

    const fvDOM& dom(refCast<const fvDOM>(radiation));

    // Get rayId and lambda Id for this ray
    label rayId = -1;
    label lambdaId = -1;
    //dom.setRayIdLambdaId(dimensionedInternalField().name(), rayId, lambdaId);
    dom.setRayIdLambdaId(internalField().name(), rayId, lambdaId);

    const labelListList& receivedRayIDs = this->receivedRayIDs();

    scalarField IValue(this->size(), 0);

    labelList faceCellIDs = this->patch().faceCells();

    // Loop over all faces and add values from all received rays
    forAll(receivedRayIDs, faceI)
    {
        if (receivedRayIDs[faceI].size() == 0)
        {
            // Ray goes into face -> act as zeroGradient
            // // this->valueFraction()[faceI] = 0;
        }
        else
        {
            // Ray goes out of face -> act as fixedValue
            //// this->valueFraction()[faceI] = 1;

            // Pick up all reflected rays
            forAll(receivedRayIDs[faceI], receivedRayI)
            {
                // Get ray from object registry
                IValue[faceI] +=
                    dom.IRayLambda
                    (
                        receivedRayIDs[faceI][receivedRayI],
                        lambdaId
                    ).internalField()[faceCellIDs[faceI]];
            }
        }
    }

/*
    // Set value for patch
    this->refValue() = IValue;

    scalarField::operator=
    (
        this->valueFraction()*this->refValue()
      +
        (1.0 - this->valueFraction())*
        (
            this->patchInternalField()
          + this->refGrad()/this->patch().deltaCoeffs()
        )
    );
*/
    wedgeFvPatchField<scalar>::updateCoeffs();

}


void specularRadiationWedgeFvPatchScalarField::write(Ostream& os) const
{
    fvPatchScalarField::write(os);
    this->writeEntry("value", os);
}


// * * * * * * * * * * * * * * * Member Operators  * * * * * * * * * * * * * //

void specularRadiationWedgeFvPatchScalarField::operator=
(
    const fvPatchScalarField& ptf
)
{
    /*
    fvPatchScalarField::operator=
    (
        this->valueFraction()*this->refValue()
        + (1 - this->valueFraction())*ptf
    );
    */
}


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

makePatchTypeField
(
   fvPatchScalarField,
   // wedgeFvPatchField<scalar>, ?
   specularRadiationWedgeFvPatchScalarField
);


} // End namespace radiation
} // End namespace Foam

// ************************************************************************* //
